ones
seq(10, 200, by = 20)
sizes <- seq(10, 300, by = 30)
sizes
sizes <- seq(10, 350, by = 50)
length(sizes)
sizes <- seq(10, 350, by = 40)
length(sizes)
seq(10, 390, by = 40)
i=1
alpha0=0.95
Tmax <- 30 #number of years in data#
  k1 <- 20 #size at first reproduction (could be indexed by species i)#
  k2 <- 350 #maximum size for a species (could be indexed by species i)
alpha0[i]*(k2-(1:k2))/(k2-1)
plot(alpha0[i]*(k2-(1:k2))/(k2-1)
)
####parameters and data inputs  #
  species <- 1:7 #list of species#
  sizes <- seq(10, 390, by = 40) #list of size class cutoffs#
  fisheries <- 1:5 #list of fisheries#
Tmax <- 30 #number of years in data#
  k1 <- 2#size at first reproduction (could be indexed by species i)#
  k2 <- length(sizes) #maximum size for a species (could be indexed by species i)
alpha0[i]*sizes[k2]-(sizes[1:k2]))/(sizes[k2]-1)
alpha0[i]*(sizes[k2]-(sizes[1:k2]))/(sizes[k2]-1)  #leaving this in the species loop because we may need a different growth rate for every species
alpha <- matrix(nrow=length(species), ncol=length(sizes), data = alpha0*(sizes[k2]-(sizes[1:k2]))/(sizes[k2]-1) )  #describe probability of transition from one size
alpha
alpha <- matrix(nrow=length(species), ncol=length(sizes), data = alpha0[species]*(sizes[k2]-(sizes[1:k2]))/(sizes[k2]-1) )  #describe probability of transition from one size class to the next for every species.
alpha0<-rep(0.95, length(species)) #Growth rat
alpha <- matrix(nrow=length(species), ncol=length(sizes), data = alpha0[species]*(sizes[k2]-(sizes[1:k2]))/(sizes[k2]-1) )  #describe probability of transition from one size class to the next for every species.
alpha0*(sizes[k2]-(sizes[1:k2]))/(sizes[k2]-1)
species <- 1:7 #list of species
matrix(nrow=length(species), ncol=length(sizes), data = alpha0*(sizes[k2]-(sizes[1:k2]))/(sizes[k2]-1) )  #describe probability of transition from one size class to the n
alpha0*(sizes[k2]-(sizes[1:k2]))/(sizes[k2]-1)
alpha0[species]*(sizes[k2]-(sizes[1:k2]))/(sizes[k2]-1)
sizes[k2]-(sizes[1:k2]))/(sizes[k2]-1)
(sizes[k2]-(sizes[1:k2]))/(sizes[k2]-1)
(1:10) * (sizes[k2]-(sizes[1:k2]))/(sizes[k2]-1)
alpha0=0.99#
  alpha <- matrix(nrow=length(species), ncol=length(sizes), data = alpha0*(sizes[k2]-(sizes[1:k2]))/(sizes[k2]-1) )  #describe probability of transition from one size class to the next for every species.
alpha
alpha0=0.99#
  alpha <- matrix(nrow=length(species), ncol=length(sizes), data = t(alpha0*(sizes[k2]-(sizes[1:k2]))/(sizes[k2]-1)) )  #describe probability of transition from one size class to the next for every species.
alpha
alpha <- matrix(nrcol=length(species), nrow=length(sizes), data = t(alpha0*(sizes[k2]-(sizes[1:k2]))/(sizes[k2]-1)) )  #describe probability of transition from one size class to the next for every species.
alpha <- matrix(ncol=length(species), nrow=length(sizes), data = t(alpha0*(sizes[k2]-(sizes[1:k2]))/(sizes[k2]-1)) )  #describe probability of transition from one size class to the next for every species.
alpha
alpha0=0.99#
  alpha <- t(matrix(ncol=length(species), nrow=length(sizes), data = alpha0*(sizes[k2]-(sizes[1:k2]))/(sizes[k2]-1) ))  #describe probability of transition from one size class to the next for every species.
####parameters and data inputs  #
  species <- 1:7 #list of species#
  sizes <- seq(10, 390, by = 40) #list of size class cutoffs#
  fisheries <- 1:5 #list of fisheries#
Tmax <- 30 #number of years in data#
  k1 <- 2#size at first reproduction (could be indexed by species i)#
  k2 <- length(sizes) #maximum size for a species (could be indexed by species i)#
  fec_coef <- 2000 #size-specific fecunidty coefficient (could be indexed by species i)#
  alpha0<-rep(0.95, length(species)) #Growth rate of smallest size class, (could be indexed by species i)#
    sig <- exp(-mu[1:k2]) #survival... this could be different for every species#
#
  mu <- rep(0.1, k2) #constant mortality for the time being, could be a matrix of species x size (see alpha)#
  alpha0=0.99#
  alpha <- t(matrix(ncol=length(species), nrow=length(sizes), data = alpha0*(sizes[k2]-(sizes[1:k2]))/(sizes[k2]-1) ))  #describe probability of transition from one size class to the next for every species.#
  q <- array(dim=c(length(species), length(fisheries), length(sizes)), data=NA) #need a table specifiying selectivity/gear efficiency of every fishery for every size class for every species#
  p <- matrix(nrow=length(species), ncol=length(fisheries), data=NA) #need a table specifying for every species x fishery combo the proportion of catch the fishery catch that is made up of that species#
#
  #storage arrays (to be filled) #
  f <- matrix(nrow = length(species), ncol=length(sizes), data=0)  #demographic matrix#
  N <- array(dim=c(length(species), length(sizes),  Tmax)) #abundance over time#
  fish_catch <- array(dim=c(length(species), length(fisheries), length(sizes),  Tmax)) #size-specific catch#
  total_catch <- array(dim=c(length(species), length(sizes),   Tmax)) #total catch of each size class by all fisheries     #
#Process model  #
   for(t in 1:Tmax) {#
                 for(i in 1:length(species)) {#
                       b[i,t] <- fec_coef*sum((k1:k2)^3*N[i,k1:k2,t])  #births#
                       N[i,1,t+1] <- b[i,t]+sig[i,1]*N[i, t, 1]*(1-alpha[i, 1])#
                 for(k in 2:k2) {#
                N[i,k,t+1] <- (sig[i,k-1])*N[i, t, k-1]*alpha[i, k-1] + sig[i,k]*N[i, t, k]*(1-alpha[i, k])#
                  #calculate catch of each size class from jth fishery #
                   j <- length(fisheries) #
                   fish_catch[i, 1:j, k , t+1] <- p[i,1:j]*q[i, 1:j, k]*eps[1:j, t]*N[i, k, t+1] #
                  #catch of kth size class summed for all fisheries#
		   total_catch[i, k, t]  <- sum(fish_catch[i,1:j ,k , t])#
#
                   #population dynamics:#
		    N[i, k , t+1] <- N[i,k,t+1] - total_catch[i, k, t] #
                 } #end k loop              #
          } #end i loop #
    } #end t loop
####parameters and data inputs  #
  species <- 1:7 #list of species#
  sizes <- seq(10, 390, by = 40) #list of size class cutoffs#
  fisheries <- 1:5 #list of fisheries#
Tmax <- 30 #number of years in data#
  k1 <- 2#size at first reproduction (could be indexed by species i)#
  k2 <- length(sizes) #maximum size for a species (could be indexed by species i)#
  fec_coef <- 2000 #size-specific fecunidty coefficient (could be indexed by species i)#
  alpha0<-rep(0.95, length(species)) #Growth rate of smallest size class, (could be indexed by species i)#
    sig <- exp(-mu[1:k2]) #survival... this could be different for every species#
#
  mu <- rep(0.1, k2) #constant mortality for the time being, could be a matrix of species x size (see alpha)#
  alpha0=0.99#
  alpha <- t(matrix(ncol=length(species), nrow=length(sizes), data = alpha0*(sizes[k2]-(sizes[1:k2]))/(sizes[k2]-1) ))  #describe probability of transition from one size class to the next for every species.#
#
 b <- matrix(nrow=length(species),  ncol=Tmax, data=0)  #
#
  q <- array(dim=c(length(species), length(fisheries), length(sizes)), data=NA) #need a table specifiying selectivity/gear efficiency of every fishery for every size class for every species#
  p <- matrix(nrow=length(species), ncol=length(fisheries), data=NA) #need a table specifying for every species x fishery combo the proportion of catch the fishery catch that is made up of that species#
#
  #storage arrays (to be filled) #
  f <- matrix(nrow = length(species), ncol=length(sizes), data=0)  #demographic matrix#
  N <- array(dim=c(length(species), length(sizes),  Tmax)) #abundance over time#
  fish_catch <- array(dim=c(length(species), length(fisheries), length(sizes),  Tmax)) #size-specific catch#
  total_catch <- array(dim=c(length(species), length(sizes),   Tmax)) #total catch of each size class by all fisheries     #
#Process model  #
   for(t in 1:Tmax) {#
                 for(i in 1:length(species)) {#
                       b[i,t] <- fec_coef*sum((k1:k2)^3*N[i,k1:k2,t])  #births#
                       N[i,1,t+1] <- b[i,t]+sig[i,1]*N[i, t, 1]*(1-alpha[i, 1])#
                 for(k in 2:k2) {#
                N[i,k,t+1] <- (sig[i,k-1])*N[i, t, k-1]*alpha[i, k-1] + sig[i,k]*N[i, t, k]*(1-alpha[i, k])#
                  #calculate catch of each size class from jth fishery #
                   j <- length(fisheries) #
                   fish_catch[i, 1:j, k , t+1] <- p[i,1:j]*q[i, 1:j, k]*eps[1:j, t]*N[i, k, t+1] #
                  #catch of kth size class summed for all fisheries#
		   total_catch[i, k, t]  <- sum(fish_catch[i,1:j ,k , t])#
#
                   #population dynamics:#
		    N[i, k , t+1] <- N[i,k,t+1] - total_catch[i, k, t] #
                 } #end k loop              #
          } #end i loop #
    } #end t loop
sig <-  t(matrix(ncol=length(species), nrow=length(sizes), data = exp(-mu))
)
sig <-  t(matrix(ncol=length(species), nrow=length(sizes), data = exp(-mu)) )
sig
####parameters and data inputs  #
  species <- 1:7 #list of species#
  sizes <- seq(10, 390, by = 40) #list of size class cutoffs#
  fisheries <- 1:5 #list of fisheries#
Tmax <- 30 #number of years in data#
  k1 <- 2#size at first reproduction (could be indexed by species i)#
  k2 <- length(sizes) #maximum size for a species (could be indexed by species i)#
  fec_coef <- 2000 #size-specific fecunidty coefficient (could be indexed by species i)#
  alpha0<-rep(0.95, length(species)) #Growth rate of smallest size class, (could be indexed by species i)#
 mu <- 0.1#constant mortality for the time being, could be a matrix of species x size (see alpha)#
 sig <-  t(matrix(ncol=length(species), nrow=length(sizes), data = exp(-mu)) )#
 alpha0=0.99#
 alpha <- t(matrix(ncol=length(species), nrow=length(sizes), data = alpha0*(sizes[k2]-(sizes[1:k2]))/(sizes[k2]-1) ))  #describe probability of transition from one size class to the next for every species.#
#
 b <- matrix(nrow=length(species),  ncol=Tmax, data=0)  #
#
  q <- array(dim=c(length(species), length(fisheries), length(sizes)), data=NA) #need a table specifiying selectivity/gear efficiency of every fishery for every size class for every species#
  p <- matrix(nrow=length(species), ncol=length(fisheries), data=NA) #need a table specifying for every species x fishery combo the proportion of catch the fishery catch that is made up of that species#
#
  #storage arrays (to be filled) #
  f <- matrix(nrow = length(species), ncol=length(sizes), data=0)  #demographic matrix#
  N <- array(dim=c(length(species), length(sizes),  Tmax)) #abundance over time#
  fish_catch <- array(dim=c(length(species), length(fisheries), length(sizes),  Tmax)) #size-specific catch#
  total_catch <- array(dim=c(length(species), length(sizes),   Tmax)) #total catch of each size class by all fisheries     #
#Process model  #
   for(t in 1:Tmax) {#
                 for(i in 1:length(species)) {#
                       b[i,t] <- fec_coef*sum((k1:k2)^3*N[i,k1:k2,t])  #births#
                       N[i,1,t+1] <- b[i,t]+sig[i,1]*N[i, t, 1]*(1-alpha[i, 1])#
                 for(k in 2:k2) {#
                N[i,k,t+1] <- (sig[i,k-1])*N[i, t, k-1]*alpha[i, k-1] + sig[i,k]*N[i, t, k]*(1-alpha[i, k])#
                  #calculate catch of each size class from jth fishery #
                   j <- length(fisheries) #
                   fish_catch[i, 1:j, k , t+1] <- p[i,1:j]*q[i, 1:j, k]*eps[1:j, t]*N[i, k, t+1] #
                  #catch of kth size class summed for all fisheries#
		   total_catch[i, k, t]  <- sum(fish_catch[i,1:j ,k , t])#
#
                   #population dynamics:#
		    N[i, k , t+1] <- N[i,k,t+1] - total_catch[i, k, t] #
                 } #end k loop              #
          } #end i loop #
    } #end t loop
####parameters and data inputs  #
  species <- 1:7 #list of species#
  sizes <- seq(10, 390, by = 40) #list of size class cutoffs#
  fisheries <- 1:5 #list of fisheries#
Tmax <- 30 #number of years in data#
  k1 <- 2#size at first reproduction (could be indexed by species i)#
  k2 <- length(sizes) #maximum size for a species (could be indexed by species i)#
  fec_coef <- 2000 #size-specific fecunidty coefficient (could be indexed by species i)#
  alpha0<-rep(0.95, length(species)) #Growth rate of smallest size class, (could be indexed by species i)#
 mu <- 0.1#constant mortality for the time being, could be a matrix of species x size (see alpha)#
 sig <-  t(matrix(ncol=length(species), nrow=length(sizes), data = exp(-mu)) )#
 alpha0=0.99#
 alpha <- t(matrix(ncol=length(species), nrow=length(sizes), data = alpha0*(sizes[k2]-(sizes[1:k2]))/(sizes[k2]-1) ))  #describe probability of transition from one size class to the next for every species.#
#
 b <- matrix(nrow=length(species),  ncol=Tmax, data=0)  #
#
  q <- array(dim=c(length(species), length(fisheries), length(sizes)), data=NA) #need a table specifiying selectivity/gear efficiency of every fishery for every size class for every species#
  p <- matrix(nrow=length(species), ncol=length(fisheries), data=NA) #need a table specifying for every species x fishery combo the proportion of catch the fishery catch that is made up of that species#
#
eps <-  matrix(nrow=length(fisheries), ncol=Tmax, data=NA) #
#
  #storage arrays (to be filled) #
  f <- matrix(nrow = length(species), ncol=length(sizes), data=0)  #demographic matrix#
  N <- array(dim=c(length(species), length(sizes),  Tmax)) #abundance over time#
  fish_catch <- array(dim=c(length(species), length(fisheries), length(sizes),  Tmax)) #size-specific catch#
  total_catch <- array(dim=c(length(species), length(sizes),   Tmax)) #total catch of each size class by all fisheries     #
#Process model  #
   for(t in 1:Tmax) {#
                 for(i in 1:length(species)) {#
                       b[i,t] <- fec_coef*sum((k1:k2)^3*N[i,k1:k2,t])  #births#
                       N[i,1,t+1] <- b[i,t]+sig[i,1]*N[i, t, 1]*(1-alpha[i, 1])#
                 for(k in 2:k2) {#
                N[i,k,t+1] <- (sig[i,k-1])*N[i, t, k-1]*alpha[i, k-1] + sig[i,k]*N[i, t, k]*(1-alpha[i, k])#
                  #calculate catch of each size class from jth fishery #
                   j <- length(fisheries) #
                   fish_catch[i, 1:j, k , t+1] <- p[i,1:j]*q[i, 1:j, k]*eps[1:j, t]*N[i, k, t+1] #
                  #catch of kth size class summed for all fisheries#
		   total_catch[i, k, t]  <- sum(fish_catch[i,1:j ,k , t])#
#
                   #population dynamics:#
		    N[i, k , t+1] <- N[i,k,t+1] - total_catch[i, k, t] #
                 } #end k loop              #
          } #end i loop #
    } #end t loop
t
Tmax
dim(N)
####parameters and data inputs  #
  species <- 1:7 #list of species#
  sizes <- seq(10, 390, by = 40) #list of size class cutoffs#
  fisheries <- 1:5 #list of fisheries#
Tmax <- 30 #number of years in data#
  k1 <- 2#size at first reproduction (could be indexed by species i)#
  k2 <- length(sizes) #maximum size for a species (could be indexed by species i)#
  fec_coef <- 2000 #size-specific fecunidty coefficient (could be indexed by species i)#
  alpha0<-rep(0.95, length(species)) #Growth rate of smallest size class, (could be indexed by species i)#
 mu <- 0.1#constant mortality for the time being, could be a matrix of species x size (see alpha)#
 sig <-  t(matrix(ncol=length(species), nrow=length(sizes), data = exp(-mu)) )#
 alpha0=0.99#
 alpha <- t(matrix(ncol=length(species), nrow=length(sizes), data = alpha0*(sizes[k2]-(sizes[1:k2]))/(sizes[k2]-1) ))  #describe probability of transition from one size class to the next for every species.#
#
 b <- matrix(nrow=length(species),  ncol=Tmax, data=0)  #
#
  q <- array(dim=c(length(species), length(fisheries), length(sizes)), data=NA) #need a table specifiying selectivity/gear efficiency of every fishery for every size class for every species#
  p <- matrix(nrow=length(species), ncol=length(fisheries), data=NA) #need a table specifying for every species x fishery combo the proportion of catch the fishery catch that is made up of that species#
#
eps <-  matrix(nrow=length(fisheries), ncol=Tmax, data=NA) #
#
  #storage arrays (to be filled) #
  f <- matrix(nrow = length(species), ncol=length(sizes), data=0)  #demographic matrix#
  N <- array(dim=c(length(species), Tmax, length(sizes))) #abundance over time#
  fish_catch <- array(dim=c(length(species), length(fisheries), length(sizes),  Tmax)) #size-specific catch#
  total_catch <- array(dim=c(length(species), length(sizes),   Tmax)) #total catch of each size class by all fisheries     #
#Process model  #
   for(t in 1:Tmax) {#
                 for(i in 1:length(species)) {#
                       b[i,t] <- fec_coef*sum((k1:k2)^3*N[i,k1:k2,t])  #births#
                       N[i,1,t+1] <- b[i,t]+sig[i,1]*N[i, t, 1]*(1-alpha[i, 1])#
                 for(k in 2:k2) {#
                N[i,k,t+1] <- (sig[i,k-1])*N[i, t, k-1]*alpha[i, k-1] + sig[i,k]*N[i, t, k]*(1-alpha[i, k])#
                  #calculate catch of each size class from jth fishery #
                   j <- length(fisheries) #
                   fish_catch[i, 1:j, k , t+1] <- p[i,1:j]*q[i, 1:j, k]*eps[1:j, t]*N[i, k, t+1] #
                  #catch of kth size class summed for all fisheries#
		   total_catch[i, k, t]  <- sum(fish_catch[i,1:j ,k , t])#
#
                   #population dynamics:#
		    N[i, k , t+1] <- N[i,k,t+1] - total_catch[i, k, t] #
                 } #end k loop              #
          } #end i loop #
    } #end t loop
####parameters and data inputs  #
  species <- 1:7 #list of species#
  sizes <- seq(10, 390, by = 40) #list of size class cutoffs#
  fisheries <- 1:5 #list of fisheries#
Tmax <- 30 #number of years in data#
  k1 <- 2#size at first reproduction (could be indexed by species i)#
  k2 <- length(sizes) #maximum size for a species (could be indexed by species i)#
  fec_coef <- 2000 #size-specific fecunidty coefficient (could be indexed by species i)#
  alpha0<-rep(0.95, length(species)) #Growth rate of smallest size class, (could be indexed by species i)#
 mu <- 0.1#constant mortality for the time being, could be a matrix of species x size (see alpha)#
 sig <-  t(matrix(ncol=length(species), nrow=length(sizes), data = exp(-mu)) )#
 alpha0=0.99#
 alpha <- t(matrix(ncol=length(species), nrow=length(sizes), data = alpha0*(sizes[k2]-(sizes[1:k2]))/(sizes[k2]-1) ))  #describe probability of transition from one size class to the next for every species.#
#
 b <- matrix(nrow=length(species),  ncol=Tmax, data=0)  #
#
  q <- array(dim=c(length(species), length(fisheries), length(sizes)), data=NA) #need a table specifiying selectivity/gear efficiency of every fishery for every size class for every species#
  p <- matrix(nrow=length(species), ncol=length(fisheries), data=NA) #need a table specifying for every species x fishery combo the proportion of catch the fishery catch that is made up of that species#
#
eps <-  matrix(nrow=length(fisheries), ncol=Tmax, data=NA) #
#
  #storage arrays (to be filled) #
  f <- matrix(nrow = length(species), ncol=length(sizes), data=0)  #demographic matrix#
  N <- array(dim=c(length(species), Tmax, length(sizes))) #abundance over time#
  fish_catch <- array(dim=c(length(species), length(fisheries), length(sizes),  Tmax)) #size-specific catch#
  total_catch <- array(dim=c(length(species), length(sizes),   Tmax)) #total catch of each size class by all fisheries     #
#Process model  #
   for(t in 1:Tmax) {#
                 for(i in 1:length(species)) {#
                       b[i,t] <- fec_coef*sum((k1:k2)^3*N[i,k1:k2,t])  #births#
                       N[i,1, t+1] <- b[i,t]+sig[i,1]*N[i, 1, t]*(1-alpha[i, 1])#
                 for(k in 2:k2) {#
                N[i, k, t+1] <- (sig[i,k-1])*N[i, k-1, t]*alpha[i, k-1] + sig[i,k]*N[i, k, t]*(1-alpha[i, k])#
                  #calculate catch of each size class from jth fishery #
                   j <- length(fisheries) #
                   fish_catch[i, 1:j, k , t+1] <- p[i,1:j]*q[i, 1:j, k]*eps[1:j, t]*N[i, k, t+1] #
                  #catch of kth size class summed for all fisheries#
		   total_catch[i, k, t]  <- sum(fish_catch[i,1:j ,k , t])#
#
                   #population dynamics:#
		    N[i, k , t+1] <- N[i,k,t+1] - total_catch[i, k, t] #
                 } #end k loop              #
          } #end i loop #
    } #end t loop
####parameters and data inputs  #
  species <- 1:7 #list of species#
  sizes <- seq(10, 390, by = 40) #list of size class cutoffs#
  fisheries <- 1:5 #list of fisheries#
Tmax <- 30 #number of years in data#
  k1 <- 2#size at first reproduction (could be indexed by species i)#
  k2 <- length(sizes) #maximum size for a species (could be indexed by species i)#
  fec_coef <- 2000 #size-specific fecunidty coefficient (could be indexed by species i)#
  alpha0<-rep(0.95, length(species)) #Growth rate of smallest size class, (could be indexed by species i)#
 mu <- 0.1#constant mortality for the time being, could be a matrix of species x size (see alpha)#
 sig <-  t(matrix(ncol=length(species), nrow=length(sizes), data = exp(-mu)) )#
 alpha0=0.99#
 alpha <- t(matrix(ncol=length(species), nrow=length(sizes), data = alpha0*(sizes[k2]-(sizes[1:k2]))/(sizes[k2]-1) ))  #describe probability of transition from one size class to the next for every species.#
#
 b <- matrix(nrow=length(species),  ncol=Tmax, data=0)  #
#
  q <- array(dim=c(length(species), length(fisheries), length(sizes)), data=NA) #need a table specifiying selectivity/gear efficiency of every fishery for every size class for every species#
  p <- matrix(nrow=length(species), ncol=length(fisheries), data=NA) #need a table specifying for every species x fishery combo the proportion of catch the fishery catch that is made up of that species#
#
eps <-  matrix(nrow=length(fisheries), ncol=Tmax, data=NA) #
#
  #storage arrays (to be filled) #
  f <- matrix(nrow = length(species), ncol=length(sizes), data=0)  #demographic matrix#
  N <- array(dim=c(length(species), Tmax, length(sizes))) #abundance over time#
  fish_catch <- array(dim=c(length(species), length(fisheries), length(sizes),  Tmax)) #size-specific catch#
  total_catch <- array(dim=c(length(species), length(sizes),   Tmax)) #total catch of each size class by all fisheries     #
#Process model  #
   for(t in 1:(Tmax-1)) {#
                 for(i in 1:length(species)) {#
                       b[i,t] <- fec_coef*sum((k1:k2)^3*N[i,k1:k2,t])  #births#
                       N[i,1, t+1] <- b[i,t]+sig[i,1]*N[i, 1, t]*(1-alpha[i, 1])#
                 for(k in 2:k2) {#
                N[i, k, t+1] <- (sig[i,k-1])*N[i, k-1, t]*alpha[i, k-1] + sig[i,k]*N[i, k, t]*(1-alpha[i, k])#
                  #calculate catch of each size class from jth fishery #
                   j <- length(fisheries) #
                   fish_catch[i, 1:j, k , t+1] <- p[i,1:j]*q[i, 1:j, k]*eps[1:j, t]*N[i, k, t+1] #
                  #catch of kth size class summed for all fisheries#
		   total_catch[i, k, t]  <- sum(fish_catch[i,1:j ,k , t])#
#
                   #population dynamics:#
		    N[i, k , t+1] <- N[i,k,t+1] - total_catch[i, k, t] #
                 } #end k loop              #
          } #end i loop #
    } #end t loop
(sig[i,k-1])*N[i, k-1, t]*alpha[i, k-1] + sig[i,k]*N[i, k, t]*(1-alpha[i, k])
i
k
t
j
b[i,t] <- fec_coef*sum((k1:k2)^3*N[i,k1:k2,t])  #births
N[i,1, t+1] <- b[i,t]+sig[i,1]*N[i, 1, t]*(1-alpha[i, 1])
b[i,t]+sig[i,1]
N[i, 1, t]
alpha[i, 1]
b[i,t]+sig[i,1]*N[i, 1, t]*(1-alpha[i, 1])
N[i,1, t+1]
dim(N)
t
N <- array(dim=c(length(species),  length(sizes), Tmax)) #abundance over time
fish_catch <- array(dim=c(length(species), length(fisheries), length(sizes),  Tmax)) #size-specific catch#
  total_catch <- array(dim=c(length(species), length(sizes),   Tmax)) #total catch of each size class by all fisheries     #
#Process model  #
   for(t in 1:(Tmax-1)) {#
                 for(i in 1:length(species)) {#
                       b[i,t] <- fec_coef*sum((k1:k2)^3*N[i,k1:k2,t])  #births#
                       N[i,1, t+1] <- b[i,t]+sig[i,1]*N[i, 1, t]*(1-alpha[i, 1])#
                 for(k in 2:k2) {#
                N[i, k, t+1] <- (sig[i,k-1])*N[i, k-1, t]*alpha[i, k-1] + sig[i,k]*N[i, k, t]*(1-alpha[i, k])#
                  #calculate catch of each size class from jth fishery #
                   j <- length(fisheries) #
                   fish_catch[i, 1:j, k , t+1] <- p[i,1:j]*q[i, 1:j, k]*eps[1:j, t]*N[i, k, t+1] #
                  #catch of kth size class summed for all fisheries#
		   total_catch[i, k, t]  <- sum(fish_catch[i,1:j ,k , t])#
#
                   #population dynamics:#
		    N[i, k , t+1] <- N[i,k,t+1] - total_catch[i, k, t] #
                 } #end k loop              #
          } #end i loop #
    } #end t loop
N
####parameters and data inputs  #
  species <- 1:7 #list of species#
  sizes <- seq(10, 390, by = 40) #list of size class cutoffs#
  fisheries <- 1 #list of fisheries#
Tmax <- 30 #number of years in data#
  k1 <- 2#size at first reproduction (could be indexed by species i)#
  k2 <- length(sizes) #maximum size for a species (could be indexed by species i)#
  fec_coef <- 2000 #size-specific fecunidty coefficient (could be indexed by species i)#
  alpha0<-rep(0.95, length(species)) #Growth rate of smallest size class, (could be indexed by species i)#
 mu <- 0.1#constant mortality for the time being, could be a matrix of species x size (see alpha)#
 sig <-  t(matrix(ncol=length(species), nrow=length(sizes), data = exp(-mu)) )#
 alpha0=0.99#
 alpha <- t(matrix(ncol=length(species), nrow=length(sizes), data = alpha0*(sizes[k2]-(sizes[1:k2]))/(sizes[k2]-1) ))  #describe probability of transition from one size class to the next for every species.#
#
 b <- matrix(nrow=length(species),  ncol=Tmax, data=0)  #
#
  q <- array(dim=c(length(species), length(fisheries), length(sizes)), data=1) #need a table specifiying selectivity/gear efficiency of every fishery for every size class for every species#
  p <- matrix(nrow=length(species), ncol=length(fisheries), data=(1/(length(species))) #need a table specifying for every species x fishery combo the proportion of catch the fishery catch that is made up of that species#
#
eps <-  matrix(nrow=length(fisheries), ncol=Tmax, data=NA) #
#
  #storage arrays (to be filled) #
  f <- matrix(nrow = length(species), ncol=length(sizes), data=0)  #demographic matrix#
  N <- array(dim=c(length(species),  length(sizes), Tmax)) #abundance over time#
  fish_catch <- array(dim=c(length(species), length(fisheries), length(sizes),  Tmax)) #size-specific catch#
  total_catch <- array(dim=c(length(species), length(sizes),   Tmax)) #total catch of each size class by all fisheries     #
#Process model  #
   for(t in 1:(Tmax-1)) {#
                 for(i in 1:length(species)) {#
                       b[i,t] <- fec_coef*sum((k1:k2)^3*N[i,k1:k2,t])  #births#
                       N[i,1, t+1] <- b[i,t]+sig[i,1]*N[i, 1, t]*(1-alpha[i, 1])#
                 for(k in 2:k2) {#
                N[i, k, t+1] <- (sig[i,k-1])*N[i, k-1, t]*alpha[i, k-1] + sig[i,k]*N[i, k, t]*(1-alpha[i, k])#
                  #calculate catch of each size class from jth fishery #
                   j <- length(fisheries) #
                   fish_catch[i, 1:j, k , t+1] <- p[i,1:j]*q[i, 1:j, k]*eps[1:j, t]*N[i, k, t+1] #
                  #catch of kth size class summed for all fisheries#
		   total_catch[i, k, t]  <- sum(fish_catch[i,1:j ,k , t])#
#
                   #population dynamics:#
		    N[i, k , t+1] <- N[i,k,t+1] - total_catch[i, k, t] #
                 } #end k loop              #
          } #end i loop #
    } #end t loop
N
N <- array(dim=c(length(species),  length(sizes), Tmax)) #abundance over time#
N<[, , 1] <- rep(100, length(species)*k2)
N[, , 1] <- rep(100, length(species)*k2)
N
t=1
b[i,t]+sig[i,1]*N[i, 1, t]*(1-alpha[i, 1])
b[i,t]
matrix(nrow=length(species),  ncol=Tmax, data=0)
b[i,t]
i
b <- matrix(nrow=length(species),  ncol=Tmax, data=0)
q <- array(dim=c(length(species), length(fisheries), length(sizes)), data=1) #need a table specifiying selectivity/gear efficiency of every fishery for every size class for every species#
  p <- matrix(nrow=length(species), ncol=length(fisheries), data=(1/(length(species))) #need a table specifying for every species x fishery combo the proportion of catch the fishery catch that is made up of that species#
#
eps <-  matrix(nrow=length(fisheries), ncol=Tmax, data=NA) #
#
  #storage arrays (to be filled) #
  f <- matrix(nrow = length(species), ncol=length(sizes), data=0)  #demographic matrix#
  N <- array(dim=c(length(species),  length(sizes), Tmax)) #abundance over time#
  N[, , 1] <- rep(100, length(species)*k2)#
  fish_catch <- array(dim=c(length(species), length(fisheries), length(sizes),  Tmax)) #size-specific catch#
  total_catch <- array(dim=c(length(species), length(sizes),   Tmax)) #total catch of each size class by all fisheries
b[i,t] <- fec_coef*sum((k1:k2)^3*N[i,k1:k2,t])  #births
b
N[i,1, t+1] <- b[i,t]+sig[i,1]*N[i, 1, t]*(1-alpha[i, 1])
N
j <- length(fisheries) #
                   fish_catch[i, 1:j, k , t+1] <- p[i,1:j]*q[i, 1:j, k]*eps[1:j, t]*N[i, k, t+1] #
                  #catch of kth size class summed for all fisheries#
		   total_catch[i, k, t]  <- sum(fish_catch[i,1:j ,k , t])#
#
                   #population dynamics:#
		    N[i, k , t+1] <- N[i,k,t+1] - total_catch[i, k, t]
N
for(k in 2:k2) {#
                N[i, k, t+1] <- (sig[i,k-1])*N[i, k-1, t]*alpha[i, k-1] + sig[i,k]*N[i, k, t]*(1-alpha[i, k])#
                  #calculate catch of each size class from jth fishery #
                   j <- length(fisheries) #
                   fish_catch[i, 1:j, k , t+1] <- p[i,1:j]*q[i, 1:j, k]*eps[1:j, t]*N[i, k, t+1] #
                  #catch of kth size class summed for all fisheries#
		   total_catch[i, k, t]  <- sum(fish_catch[i,1:j ,k , t])#
#
                   #population dynamics:#
		    N[i, k , t+1] <- N[i,k,t+1] - total_catch[i, k, t] #
                 } #end k loop
N
(sig[i,k-1])*N[i, k-1, t]*alpha[i, k-1] + sig[i,k]*N[i, k, t]*(1-alpha[i, k])
N[i, k, t+1]
(sig[i,k-1])*N[i, k-1, t]*alpha[i, k-1] + sig[i,k]*N[i, k, t]*(1-alpha[i, k])
k
k=2
(sig[i,k-1])*N[i, k-1, t]*alpha[i, k-1] + sig[i,k]*N[i, k, t]*(1-alpha[i, k])
N[i, k, t+1] <- (sig[i,k-1])*N[i, k-1, t]*alpha[i, k-1] + sig[i,k]*N[i, k, t]*(1-alpha[i, k])
N
j <- length(fisheries) #
                   fish_catch[i, 1:j, k , t+1] <- p[i,1:j]*q[i, 1:j, k]*eps[1:j, t]*N[i, k, t+1] #
                  #catch of kth size class summed for all fisheries#
		   total_catch[i, k, t]  <- sum(fish_catch[i,1:j ,k , t])#
#
                   #population dynamics:#
		    N[i, k , t+1] <- N[i,k,t+1] - total_catch[i, k, t]
N
p[i,1:j]*q[i, 1:j, k]*eps[1:j, t]*N[i, k, t+1]
eps[1:j, t]
eps <-  matrix(nrow=length(fisheries), ncol=Tmax, data=0.2) #
#
  #storage arrays (to be filled) #
  f <- matrix(nrow = length(species), ncol=length(sizes), data=0)  #demographic matrix#
  N <- array(dim=c(length(species),  length(sizes), Tmax)) #abundance over time#
  N[, , 1] <- rep(100, length(species)*k2)#
  fish_catch <- array(dim=c(length(species), length(fisheries), length(sizes),  Tmax)) #size-specific catch#
  total_catch <- array(dim=c(length(species), length(sizes),   Tmax)) #total catch of each size class by all fisheries     #
#Process model  #
   for(t in 1:(Tmax-1)) {#
                 for(i in 1:length(species)) {#
                       b[i,t] <- fec_coef*sum((k1:k2)^3*N[i,k1:k2,t])  #births#
                       N[i,1, t+1] <- b[i,t]+sig[i,1]*N[i, 1, t]*(1-alpha[i, 1])#
                 for(k in 2:k2) {#
                N[i, k, t+1] <- (sig[i,k-1])*N[i, k-1, t]*alpha[i, k-1] + sig[i,k]*N[i, k, t]*(1-alpha[i, k])#
                  #calculate catch of each size class from jth fishery #
                   j <- length(fisheries) #
                   fish_catch[i, 1:j, k , t+1] <- p[i,1:j]*q[i, 1:j, k]*eps[1:j, t]*N[i, k, t+1] #
                  #catch of kth size class summed for all fisheries#
		   total_catch[i, k, t]  <- sum(fish_catch[i,1:j ,k , t])#
#
                   #population dynamics:#
		    N[i, k , t+1] <- N[i,k,t+1] - total_catch[i, k, t] #
                 } #end k loop              #
          } #end i loop #
    } #end t loop
NA
N
i=1
t=2
k=2
(sig[i,k-1])*N[i, k-1, t]*alpha[i, k-1] + sig[i,k]*N[i, k, t]*(1-alpha[i, k])
(sig[i,k-1])
*N[i, k-1, t]
N[i, k-1, t]
alpha[i, k-1]
sig[i,k]
N[i, k, t]
(1-alpha[i, k])
t=1
N[i,1, t+1] <- b[i,t]+sig[i,1]*N[i, 1, t]*(1-alpha[i, 1])
N[i, k, t+1] <- (sig[i,k-1])*N[i, k-1, t]*alpha[i, k-1] + sig[i,k]*N[i, k, t]*(1-alpha[i, k])
N
for(k in 2:k2) {#
                N[i, k, t+1] <- (sig[i,k-1])*N[i, k-1, t]*alpha[i, k-1] + sig[i,k]*N[i, k, t]*(1-alpha[i, k])#
                  #calculate catch of each size class from jth fishery #
                   j <- length(fisheries) #
                   fish_catch[i, 1:j, k , t+1] <- p[i,1:j]*q[i, 1:j, k]*eps[1:j, t]*N[i, k, t+1] #
                  #catch of kth size class summed for all fisheries#
		   total_catch[i, k, t]  <- sum(fish_catch[i,1:j ,k , t])#
#
                   #population dynamics:#
		    N[i, k , t+1] <- N[i,k,t+1] - total_catch[i, k, t] #
                 } #end k loop
N[,,2]
dim(N)
k2
k1
k
k=2
(sig[i,k-1])*N[i, k-1, t]*alpha[i, k-1] + sig[i,k]*N[i, k, t]*(1-alpha[i, k])
i
N[i, k, t+1] <- (sig[i,k-1])*N[i, k-1, t]*alpha[i, k-1] + sig[i,k]*N[i, k, t]*(1-alpha[i, k])
N[,,2]
j <- length(fisheries) #
                   fish_catch[i, 1:j, k , t+1] <- p[i,1:j]*q[i, 1:j, k]*eps[1:j, t]*N[i, k, t+1]
fish_catch[i, 1:j, k , t+1]
N[i, k, t+1]
eps[1:j, t]*
eps[1:j, t]*N[i, k, t+1]
p[i,1:j]*q[i, 1:j, k]
*q[i, 1:j, k]
q[i, 1:j, k]
p[i,1:j]
matrix(nrow=length(species), ncol=length(fisheries), data=(1/(length(species)))
p <- matrix(nrow=length(species), ncol=length(fisheries), data=1/(length(species))) #need a table specifying for every species x fishery combo the proportion of catch the fishery catch that is made up of that species
p[i,1:j]
fish_catch[i, 1:j, k , t+1] <- p[i,1:j]*q[i, 1:j, k]*eps[1:j, t]*N[i, k, t+1]
fish_catch[i, 1:j, k , t+1]
total_catch[i, k, t]  <- sum(fish_catch[i,1:j ,k , t])
total_catch[i, k, t]
fish_catch[i, 1:j, k , t+1]
sum(fish_catch[i,1:j ,k , t])
fish_catch[i,1:j ,k , t]
fish_catch[i, 1:j, k , t+1]
total_catch[i, k, t]  <- sum( fish_catch[i, 1:j, k , t+1] )
total_catch[i, k, t+1]  <- sum( fish_catch[i, 1:j, k , t+1] )
total_catch[i, k, t+1]
#population dynamics:#
		    N[i, k , t+1] <- N[i,k,t+1] - total_catch[i, k, t]
N
N[,,,2]
N[,,2]
for(k in 2:k2) {#
                N[i, k, t+1] <- (sig[i,k-1])*N[i, k-1, t]*alpha[i, k-1] + sig[i,k]*N[i, k, t]*(1-alpha[i, k])#
                  #calculate catch of each size class from jth fishery #
                   j <- length(fisheries) #
                   fish_catch[i, 1:j, k , t+1] <- p[i,1:j]*q[i, 1:j, k]*eps[1:j, t]*N[i, k, t+1] #
                  #catch of kth size class summed for all fisheries#
		   total_catch[i, k, t+1]  <- sum( fish_catch[i, 1:j, k , t+1] )#
#
                   #population dynamics:#
		    N[i, k , t+1] <- N[i,k,t+1] - total_catch[i, k, t] #
                 } #end k loop
N[,,2]
k
k=3
N[i, k, t+1] <- (sig[i,k-1])*N[i, k-1, t]*alpha[i, k-1] + sig[i,k]*N[i, k, t]*(1-alpha[i, k])
N[i, k, t+1]
k
j <- length(fisheries) #
                   fish_catch[i, 1:j, k , t+1] <- p[i,1:j]*q[i, 1:j, k]*eps[1:j, t]*N[i, k, t+1]
fish_catch[i, , k, t+1]
total_catch[i, k, t+1]  <- sum( fish_catch[i, 1:j, k , t+1] )
total_catch[i, k, t+1]
N[i, k , t+1] <- N[i,k,t+1] - total_catch[i, k, t+1]
N[i, k, t+1]
N[,,2]
for(t in 1:(Tmax-1)) {#
                 for(i in 1:length(species)) {#
                       b[i,t] <- fec_coef*sum((k1:k2)^3*N[i,k1:k2,t])  #births#
                       N[i,1, t+1] <- b[i,t]+sig[i,1]*N[i, 1, t]*(1-alpha[i, 1])#
                 for(k in 2:k2) {#
                N[i, k, t+1] <- (sig[i,k-1])*N[i, k-1, t]*alpha[i, k-1] + sig[i,k]*N[i, k, t]*(1-alpha[i, k])#
                  #calculate catch of each size class from jth fishery #
                   j <- length(fisheries) #
                   fish_catch[i, 1:j, k , t+1] <- p[i,1:j]*q[i, 1:j, k]*eps[1:j, t]*N[i, k, t+1] #
                  #catch of kth size class summed for all fisheries#
		   total_catch[i, k, t+1]  <- sum( fish_catch[i, 1:j, k , t+1] )#
#
                   #population dynamics:#
		    N[i, k , t+1] <- N[i,k,t+1] - total_catch[i, k, t+1] #
                 } #end k loop              #
          } #end i loop #
    } #end t loop
N
Temp = 293:297 #
#describe temperature dependent costs#
#
k=1.3e-23#
#
E = 1.04e-19#
#
theta=0.66#
#
coef  = 1.2e+11 ##coef puts in the same ballpark as the costs in Thermal Ecology (Clarke) ex. #
#physiological parameters#
#
a <- 1e-5 #from ICCAT 2015 BFT length-weight relationship#
#
scale <-  4.2e+6 #J/kg #from Chapman et al. 2011#
#
b=1.8#
#
d = 2.4#
# #
#
storelimit= 1 #proportion of structural mass that inidivduals can devote to energy storage#
#
 storemin = 0.1#
#
reprolimit = 2#
#
#STATE VARIABLES#
Lmax=375  #maximum size of 4 meters#
#
Lmin = 1 #
#
phi = 1 #1 environment#
####################################################################################################################################################################################################
  Smax <- 1500  #in kg #
   Size<- Lmin:Lmax#
#
 Mass <- a*Size^3  #
#
  ###Sizespectra allow us to descripbe prey preference, encounter, consumption to predict prey availability and mass-specific mortality:#
##Prey availability   #
#
phi_a <- 3 #from table 2.2 in Andersen book#
#
 K_c <- 10 #from table 2.2, this is averaged over "all" -  lam <- 1.95 #
#
 Kappa=1 #scales K_c#
#
 Mass <- 1:1500#
#
Income = Kappa*phi_a*K_c*Mass^(0.1) #this describes the scaling with size and ecostystem richness#
#
  plot(Income, type="l", lwd=2)#
##mass dependent mortality#
#
 phi_p <- 0.07 #from table 2.2 in Andersen book#
#
 f_0 <- 0.6 #somewhere between 0 and 1, but predators rarely caught with totally full stomach#
#
 hprime <- 17.2 #coefficient on the consumption rate from table 2.2#
#
 met_mort <- -0.25 #the argument in Andersen book is that mass-specific rates such as mortality scales with the metabolic esp of 3/4 (Brown et al. 2004). #
#
   mu<- phi_p*f_0*hprime*Mass^met_mort #note we are excluding "background" mortality that is independent of size.... #
#
plot(mu, type="l", lwd = 2)#
      ###COST FUNCTIONS - assume metabolic requirements scale with body size and temperature#
#
MTcosts <- matrix(nrow=3, ncol=Smax, data=NA )  #costs in joules#
  for (S in (1:Smax)) {#
#
	for(p in 1:(3)) {#
#
		        S_g <- S #
#
		        MTcosts[p, S] <-  coef*S_g^theta*exp(-E/(k*Temp[p]))   #
#
    }#
#
  }#
###plot metabolic cost functions for each temp to check they are sensible#
#
    matplot( ((1:Smax)), t( (MTcosts)), type = "l", lty=1, lwd=2,   xlab=" (Mass (kg))", ylab=" (Metabolic rate) in J/season", col=c(4, 3, "orange", 2))  ##this version of the plot confirms the metabolic costs are on the same scale as those in Fig. 1 of Clarke and Portner 2010.
log(MTcosts)
k=1.3e-23#
E = 1.04e-19#
theta=0.66
MTcosts <- matrix(nrow=3, ncol=Smax, data=NA )  #costs in joules#
#
  for (S in (1:Smax)) {#
	for(p in 1:(3)) {#
		        S_g <- S #
		        MTcosts[p, S] <-  coef*S_g^theta*exp(-E/(k*Temp[p]))   #
    }#
  }
MTcosts[1, ]
coef
coef2 <- 2e+19
for (S in (1:Smax)) {#
	for(p in 1:(3)) {#
		        S_g <- S #
		        MTcosts[p, S] <-  coef2*S_g^theta*exp(-E/(k*Temp[p]))   #
    }#
  }
matplot( ((1:Smax)), t( (MTcosts)), type = "l", lty=1, lwd=2,   xlab=" (Mass (kg))", ylab=" (Metabolic rate) in J/season", col=c(4, 3, "orange", 2))  ##this version of the plot confirms the metabolic costs are on teh same scale as those in Fig. 1 of Clarke and POrtner 2010.  #
  #lines(Income)
coef2<- 2e+116
coef2<- 2e+16
coef2
for (S in (1:Smax)) {#
	for(p in 1:(3)) {#
		        S_g <- S #
		        MTcosts[p, S] <-  coef2*S_g^theta*exp(-E/(k*Temp[p]))   #
    }#
  }
matplot( ((1:Smax)), t( (MTcosts)), type = "l", lty=1, lwd=2,   xlab=" (Mass (kg))", ylab=" (Metabolic rate) in J/season", col=c(4, 3, "orange", 2))  ##this version of the plot confirms the metabolic costs are on teh same scale as those in Fig. 1 of Clarke and POrtner 2010.  #
  #lines(Income)
4000000
coef2<- 2e+17
matplot( ((1:Smax)), t( (MTcosts)), type = "l", lty=1, lwd=2,   xlab=" (Mass (kg))", ylab=" (Metabolic rate) in J/season", col=c(4, 3, "orange", 2))  ##this version of the plot confirms the metabolic costs are on teh same scale as those in Fig. 1 of Clarke and POrtner 2010.  #
  #lines(Income)
for (S in (1:Smax)) {#
	for(p in 1:(3)) {#
		        S_g <- S #
		        MTcosts[p, S] <-  coef2*S_g^theta*exp(-E/(k*Temp[p]))   #
    }#
  }
matplot( ((1:Smax)), t( (MTcosts)), type = "l", lty=1, lwd=2,   xlab=" (Mass (kg))", ylab=" (Metabolic rate) in J/season", col=c(4, 3, "orange", 2))  ##this version of the plot confirms the metabolic costs are on teh same scale as those in Fig. 1 of Clarke and POrtner 2010.  #
  #lines(Income)
MTcosts[1, 2]
coef2<- 2e+18
for (S in (1:Smax)) {#
	for(p in 1:(3)) {#
		        S_g <- S #
		        MTcosts[p, S] <-  coef2*S_g^theta*exp(-E/(k*Temp[p]))   #
    }#
  }
matplot( ((1:Smax)), t( (MTcosts)), type = "l", lty=1, lwd=2,   xlab=" (Mass (kg))", ylab=" (Metabolic rate) in J/season", col=c(4, 3, "orange", 2))  ##this version of the plot confirms the metabolic costs are on teh same scale as those in Fig. 1 of Clarke and POrtner 2010.  #
  #lines(Income)
MTcosts[1, 2]
coef2<- 2e+19
for (S in (1:Smax)) {#
	for(p in 1:(3)) {#
		        S_g <- S #
		        MTcosts[p, S] <-  coef2*S_g^theta*exp(-E/(k*Temp[p]))   #
    }#
  }
matplot( ((1:Smax)), t( (MTcosts)), type = "l", lty=1, lwd=2,   xlab=" (Mass (kg))", ylab=" (Metabolic rate) in J/season", col=c(4, 3, "orange", 2))  ##this version of the plot confirms the metabolic costs are on teh same scale as those in Fig. 1 of Clarke and POrtner 2010.  #
  #lines(Income)
MTcosts[1, 2]
coef2<- 1e+19
for (S in (1:Smax)) {#
	for(p in 1:(3)) {#
		        S_g <- S #
		        MTcosts[p, S] <-  coef2*S_g^theta*exp(-E/(k*Temp[p]))   #
    }#
  }
matplot( ((1:Smax)), t( (MTcosts)), type = "l", lty=1, lwd=2,   xlab=" (Mass (kg))", ylab=" (Metabolic rate) in J/season", col=c(4, 3, "orange", 2))  ##this version of the plot confirms the metabolic costs are on teh same scale as those in Fig. 1 of Clarke and POrtner 2010.  #
  #lines(Income)
MTcosts[1, 1]
scale
?dnorm
read.csv("~/Documents/species_names.csv")
library(rfishbase)
species_list <- read.csv("~/Documents/species_names.csv")
maturity(species_list)
maturity(species_list[1:5])
species_list[1:5]
maturity(species_list[1:5,1])
maturity(species_list[1:15,1])
maturity(species_list[-38,1])
maturity(species_list[1:37,1])
maturity(species_list[1:30,1])
maturity(species_list[1:20,1])
read.csv("~/Documents/species_names.csv")
is.character(species_names)
as.character(species_names)
maturity(species_list[1:5,1])
data<- maturity(species_list[1:5,1])
data
View(data)
data<- maturity(species_list[1:25,1])
data
View(data)
data<- maturity(species_list[1:30,1])
head(data)
setwd("~/Dropbox/results11Mar/")#
data_files <- list.files(pattern = "\\.csv$")#
#
repro_filenames <- data_files[((length(data_files)/3)+1):(2*(length(data_files)/3))]   #
state_filenames <- data_files[(2*(length(data_files)/3)+1):(3*(length(data_files)/3))]#
length_filenames <- data_files[1:(length(data_files)/3)]#
#
length_filenames <- unique(length_filenames)#
repro_filenames <- unique(repro_filenames)#
state_filenames <- unique(state_filenames)#
#
length_data <- lapply(length_filenames, read.csv)#
repro_data <- lapply(repro_filenames, read.csv)#
state_data <- lapply(state_filenames, read.csv)#
test_length <- read.csv("~/Dropbox/results2Apr/01LengthTemp293c10Kappa1.7.csv")#
test_repro <- read.csv("~/Dropbox/results2Apr/02ReproTemp293c10Kappa1.7.csv")#
test_state <- read.csv("~/Dropbox/results2Apr/03StateTemp293c10Kappa1.7.csv")#
 mort.est <- function(idata, filename) {#
     alive_at_age<- 10000.001 - colSums(apply(idata[,-1],2, is.na ))#
      age=1:64#
      mu_a <-  log(alive_at_age[age[-64]+1]/  alive_at_age[age[-64]])#
      asp <- which(cumprod(mu_a)<=0.01) #
     #mu_a[asp:length(mu_a)]=-5  #
     m1<- lm(log(alive_at_age) ~ age) 	#
 	 mu <- as.numeric(coef(m1)[2])#
 	 #c(filename, exp(mu), exp(mu_a))#
 	 mu#
 	 }#
mu_K <- mapply(mort.est, state_data, state_filenames)#
 #find mean of all length datasets at age 3#
 mean_L <- function(data) {#
 	mean(data[, 13], na.rm=TRUE) #take mean at age 3#
 }	 #
mean_kappa <- mapply(mean_L, length_data)#
 #find sd of all length datasets at age 3#
 sd_L <- function(data) {#
 	sd(data[, 13], na.rm=TRUE) #take mean at age 3#
 }	 #
 sd_kappa <- mapply(sd_L, length_data)#
#sample lengths and statistics#
obs_length <-  test_length[sample(1:nrow(test_length), 1000), 12]#
J <- sum(obs_length>0, na.rm=TRUE)#
mean_obs <- mean(obs_length, na.rm=TRUE)#
sd_obs <- sd(obs_length, na.rm=TRUE)#
#
kappa <- seq(0.5, 4, by=0.38)#
N_0 <- 10000#
#pooled SD for every Kappa#
SD_pooled <- rep(0, length(kappa))#
SDM <- rep(0, length(kappa))#
 for (i in 1:length(kappa)) {#
 	SD_pooled[i] <- (((N_0 - 1)*sd_kappa[i]^2 + (J-1)*sd_obs^2)/(N_0+J))^0.5#
 	SDM[i] <- abs((mean_kappa[i] - mean_obs)/SD_pooled[i])#
 	} #end i loop#
 	plot(kappa, SDM, type="l")#
 	SDM_max <- max(SDM)#
 	beta <- (-1/SDM_max)*log(0.05)#
 	#######BSU#######
 	#calculate weighting#
 	  	weight_K  <- exp(-beta*SDM) #
 	  	#calculate posterior#
 	  	f0 = 1#
 	  	f1_K <- weight_K/sum(weight_K)
plot(mu_K, f1_K, type="p", pch=19, xlim=c(-0.316, -0.30))
state_filenames
state_data<- read.csv("~/Dropbox/results2Apr/03StateTemp293c10Kappa1.7.csv")
state_filenames <- state_filenames[1]
mort.est <- function(idata, filename) {#
     alive_at_age<- 10000.001 - colSums(apply(idata[,-1],2, is.na ))#
      age=1:64#
      mu_a <-  log(alive_at_age[age[-64]+1]/  alive_at_age[age[-64]])#
      asp <- which(cumprod(mu_a)<=0.01) #
     #mu_a[asp:length(mu_a)]=-5  #
     m1<- lm(log(alive_at_age) ~ age) 	#
 	 mu <- as.numeric(coef(m1)[2])#
 	 #c(filename, exp(mu), exp(mu_a))#
 	 mu#
 	 }
mu_K <- mapply(mort.est, state_data, state_filenames)
mu <- mort.est(state_data, state_filenames)
mu
plot(abs(mu_K), f1_K, type="p", pch=19, xlim=c(-0.316, -0.30))#
  abline(v =  0.3060629, lty=3)
plot(abs(mu_K), f1_K, type="p", pch=19, xlim=c(0.3, 0.316))#
  abline(v =  0.3060629, lty=3)
plot(abs(mu_K), f1_K, type="p", pch=19, xlim=c(0.3, 0.316), xlab="Mu", ylab="Posterior")#
  abline(v =  0.3060629, lty=3)
setwd("~/Documents/tuna_theory/model_output/storemin0.4")#
data_files <- list.files(pattern = "\\.csv$")#
#
repro_filenames <- data_files[((length(data_files)/3)+1):(2*(length(data_files)/3))]   #
state_filenames <- data_files[(2*(length(data_files)/3)+1):(3*(length(data_files)/3))]#
length_filenames <- data_files[1:(length(data_files)/3)]#
#
length_filenames <- unique(length_filenames)#
repro_filenames <- unique(repro_filenames)#
state_filenames <- unique(state_filenames)#
#
length_data <- lapply(length_filenames, read.csv)#
repro_data <- lapply(repro_filenames, read.csv)#
state_data <- lapply(state_filenames, read.csv)
quartz()#
  par(mfrow=c(2, 3))#
plot_length <- function(data, filenames) {#
	  #data[is.na(data)] <- 0#
     matplot(t(data[,-1]), type="l", main=c(substr(filenames, 9, 15), substr(filenames, 16, 21)), col="darkgray", lwd=1.75, lty=1,  ylab="Length (cm)", ylim=c(0, 400), xlim=c(0.5, 48), xlab= "Age (years)", xaxt="n")#
     axis(1, at = seq(0, 64, by=4), labels = (seq(1, 17, by=1)))#
     }#
 mapply(plot_length, length_data, length_filenames)    #
  # plot_hist <- function(data, filenames) {#
    # hist(data[, 12], breaks=50, xlim=c(50, 350), main=substr(filenames, 13, 49))#
  # }#
  # mapply(plot_hist, length_data, length_filenames)#
 # quartz()#
 # #par(mfrow=c(3, 4))#
  # plot_repro <- function(repro_data, repro_filenames) {#
     # matplot(t(repro_data[,-1]), type="l", main=c(substr(repro_filenames, 8, 14), substr(repro_filenames, 18, 23)), col="darkgray", lwd=1.75, lty=1,   ylab="Reproduction (J)",   xlab= "Age (years)", xaxt="n", ylim=c(0, 6e+08), xlim=c(1, 56))#
     # axis(1, at = seq(0, 60, by=4), labels = (seq(1, 16, by=1)))#
     # }#
#
# mapply(plot_repro, repro_data, repro_filenames)#
#
##make a plot of reproductive output as a function of length#
quartz()#
  par(mfrow=c(2, 3))#
 age.length <- function(length_data, repro_data, filenames) {#
 	matplot(t(length_data[,-1]), t(repro_data[,-1]), type="l", col="darkgray", lwd=1.75, lty=1, main=c(substr(filenames, 9, 15), substr(filenames, 16, 21)),  xlab="Length (cm)", xlim=c(0, 350), ylim=c(0, 1.5e+09), ylab="Reproduction (J)")#
 	} #
mapply(age.length, length_data, repro_data, length_filenames)#
 	#####now calculate the number alive as a function of age#
 mort.est <- function(idata, filename) {#
     alive_at_age<- 10000.001 - colSums(apply(idata[,-1],2, is.na ))#
      age=1:64#
      plot(alive_at_age, type="l", lwd=2, ylab="Population size", main=c(substr(filename, 8, 14), substr(filename, 15, 20)), xlab= "Age (years)", xaxt="n", ylim=c(0, 10005), xlim=c(1, 56))#
     axis(1, at = seq(0, 60, by=4), labels = (seq(1, 16, by=1)))#
#
      mu_a <-  log(alive_at_age[age[-64]+1]/  alive_at_age[age[-64]])#
      asp <- min(which(cumprod(mu_a)<=0.01) )#
     mu_a[asp:length(mu_a)]=-5  #
     m1<- lm(log(alive_at_age) ~ age) 	#
 	 mu <- as.numeric(coef(m1)[2])#
 	 legend("topright",   legend=round(mu, 5), lty=1)#
 	 c(filename, exp(mu), exp(mu_a))#
 	 }#
quartz()#
 par(mfrow=c(2, 3))#
mapply(mort.est, state_data, state_filenames)
####in Feb 8 results, kappa (environment richness) and costs of spawning (c1) vary and overall very steep for individuals < 50#
####in Feb 11 results, kappa (environemnt richness) and temperature vary and c0 = 0.1, c1 is 0.25, so spawning costs are VERY steep for small individuals#
### in Feb 13 results, kappa and temperature vary, but there are no spawning costs (c2 = 0.1, c1=0)#
### in Feb 19 results, kappa and temperature vary, but c0 is 0.05 (and c1 is 0.15), so spawning costs are severe for individuals < 80 cm - not that interersting#
####in Feb 20 the metabolic costs get a lot steeper in warm envieonments, but there are no CoR#
###in Feb 20.2 the maximum lifespan is much longer#
###Feb 21 maximum lifespan is the same as Feb 20.2, kappa inclueds 4; max state is greater (375); also rep limit is 2#
##March 11: same as feb 21 except variance in food is zero and max lifespan is shorter (16 years)#
setwd("~/Documents/tuna_theory/model_output/storemin0.4")#
data_files <- list.files(pattern = "\\.csv$")#
#
repro_filenames <- data_files[((length(data_files)/3)+1):(2*(length(data_files)/3))]   #
state_filenames <- data_files[(2*(length(data_files)/3)+1):(3*(length(data_files)/3))]#
length_filenames <- data_files[1:(length(data_files)/3)]#
#
length_filenames <- unique(length_filenames)#
repro_filenames <- unique(repro_filenames)#
state_filenames <- unique(state_filenames)#
#
length_data <- lapply(length_filenames, read.csv)#
repro_data <- lapply(repro_filenames, read.csv)#
state_data <- lapply(state_filenames, read.csv)#
 quartz()#
  par(mfrow=c(2, 3))#
plot_length <- function(data, filenames) {#
	  #data[is.na(data)] <- 0#
     matplot(t(data[,-1]), type="l", main=c(substr(filenames, 9, 15), substr(filenames, 16, 21)), col="darkgray", lwd=1.75, lty=1,  ylab="Length (cm)", ylim=c(0, 400), xlim=c(0.5, 48), xlab= "Age (years)", xaxt="n")#
     axis(1, at = seq(0, 64, by=4), labels = (seq(1, 17, by=1)))#
     }#
 mapply(plot_length, length_data, length_filenames)    #
  # plot_hist <- function(data, filenames) {#
    # hist(data[, 12], breaks=50, xlim=c(50, 350), main=substr(filenames, 13, 49))#
  # }#
  # mapply(plot_hist, length_data, length_filenames)#
 # quartz()#
 # #par(mfrow=c(3, 4))#
  # plot_repro <- function(repro_data, repro_filenames) {#
     # matplot(t(repro_data[,-1]), type="l", main=c(substr(repro_filenames, 8, 14), substr(repro_filenames, 18, 23)), col="darkgray", lwd=1.75, lty=1,   ylab="Reproduction (J)",   xlab= "Age (years)", xaxt="n", ylim=c(0, 6e+08), xlim=c(1, 56))#
     # axis(1, at = seq(0, 60, by=4), labels = (seq(1, 16, by=1)))#
     # }#
#
# mapply(plot_repro, repro_data, repro_filenames)#
#
##make a plot of reproductive output as a function of length#
quartz()#
  par(mfrow=c(4, 4))#
 age.length <- function(length_data, repro_data, filenames) {#
 	matplot(t(length_data[,-1]), t(repro_data[,-1]), type="l", col="darkgray", lwd=1.75, lty=1, main=c(substr(filenames, 9, 15), substr(filenames, 16, 21)),  xlab="Length (cm)", xlim=c(0, 350), ylim=c(0, 1.5e+09), ylab="Reproduction (J)")#
 	} #
mapply(age.length, length_data, repro_data, length_filenames)#
 	#####now calculate the number alive as a function of age#
 mort.est <- function(idata, filename) {#
     alive_at_age<- 10000.001 - colSums(apply(idata[,-1],2, is.na ))#
      age=1:64#
      plot(alive_at_age, type="l", lwd=2, ylab="Population size", main=c(substr(filename, 8, 14), substr(filename, 15, 20)), xlab= "Age (years)", xaxt="n", ylim=c(0, 10005), xlim=c(1, 56))#
     axis(1, at = seq(0, 60, by=4), labels = (seq(1, 16, by=1)))#
#
      mu_a <-  log(alive_at_age[age[-64]+1]/  alive_at_age[age[-64]])#
      asp <- min(which(cumprod(mu_a)<=0.01) )#
     mu_a[asp:length(mu_a)]=-5  #
     m1<- lm(log(alive_at_age) ~ age) 	#
 	 mu <- as.numeric(coef(m1)[2])#
 	 legend("topright",   legend=round(mu, 5), lty=1)#
 	 c(filename, exp(mu), exp(mu_a))#
 	 }#
quartz()#
 par(mfrow=c(2, 3))#
mapply(mort.est, state_data, state_filenames)
####in Feb 8 results, kappa (environment richness) and costs of spawning (c1) vary and overall very steep for individuals < 50#
####in Feb 11 results, kappa (environemnt richness) and temperature vary and c0 = 0.1, c1 is 0.25, so spawning costs are VERY steep for small individuals#
### in Feb 13 results, kappa and temperature vary, but there are no spawning costs (c2 = 0.1, c1=0)#
### in Feb 19 results, kappa and temperature vary, but c0 is 0.05 (and c1 is 0.15), so spawning costs are severe for individuals < 80 cm - not that interersting#
####in Feb 20 the metabolic costs get a lot steeper in warm envieonments, but there are no CoR#
###in Feb 20.2 the maximum lifespan is much longer#
###Feb 21 maximum lifespan is the same as Feb 20.2, kappa inclueds 4; max state is greater (375); also rep limit is 2#
##March 11: same as feb 21 except variance in food is zero and max lifespan is shorter (16 years)#
setwd("~/Documents/tuna_theory/model_output/storemin0.4")#
data_files <- list.files(pattern = "\\.csv$")#
#
repro_filenames <- data_files[((length(data_files)/3)+1):(2*(length(data_files)/3))]   #
state_filenames <- data_files[(2*(length(data_files)/3)+1):(3*(length(data_files)/3))]#
length_filenames <- data_files[1:(length(data_files)/3)]#
#
length_filenames <- unique(length_filenames)#
repro_filenames <- unique(repro_filenames)#
state_filenames <- unique(state_filenames)#
#
length_data <- lapply(length_filenames, read.csv)#
repro_data <- lapply(repro_filenames, read.csv)#
state_data <- lapply(state_filenames, read.csv)#
 quartz()#
  par(mfrow=c(4, 4))#
plot_length <- function(data, filenames) {#
	  #data[is.na(data)] <- 0#
     matplot(t(data[,-1]), type="l", main=c(substr(filenames, 9, 15), substr(filenames, 16, 21)), col="darkgray", lwd=1.75, lty=1,  ylab="Length (cm)", ylim=c(0, 400), xlim=c(0.5, 48), xlab= "Age (years)", xaxt="n")#
     axis(1, at = seq(0, 64, by=4), labels = (seq(1, 17, by=1)))#
     }#
 mapply(plot_length, length_data, length_filenames)    #
  # plot_hist <- function(data, filenames) {#
    # hist(data[, 12], breaks=50, xlim=c(50, 350), main=substr(filenames, 13, 49))#
  # }#
  # mapply(plot_hist, length_data, length_filenames)#
 quartz()#
  par(mfrow=c(4, 4))#
  plot_repro <- function(repro_data, repro_filenames) {#
     matplot(t(repro_data[,-1]), type="l", main=c(substr(repro_filenames, 8, 14), substr(repro_filenames, 18, 23)), col="darkgray", lwd=1.75, lty=1,   ylab="Reproduction (J)",   xlab= "Age (years)", xaxt="n", ylim=c(0, 6e+08), xlim=c(1, 56))#
     axis(1, at = seq(0, 60, by=4), labels = (seq(1, 16, by=1)))#
     }#
#
mapply(plot_repro, repro_data, repro_filenames)#
#
##make a plot of reproductive output as a function of length#
quartz()#
  par(mfrow=c(4, 4))#
 age.length <- function(length_data, repro_data, filenames) {#
 	matplot(t(length_data[,-1]), t(repro_data[,-1]), type="l", col="darkgray", lwd=1.75, lty=1, main=c(substr(filenames, 9, 15), substr(filenames, 16, 21)),  xlab="Length (cm)", xlim=c(0, 350), ylim=c(0, 1.5e+09), ylab="Reproduction (J)")#
 	} #
mapply(age.length, length_data, repro_data, length_filenames)#
 	#####now calculate the number alive as a function of age#
# #  mort.est <- function(idata, filename) {#
     # alive_at_age<- 10000.001 - colSums(apply(idata[,-1],2, is.na ))#
      # age=1:64#
      # plot(alive_at_age, type="l", lwd=2, ylab="Population size", main=c(substr(filename, 8, 14), substr(filename, 15, 20)), xlab= "Age (years)", xaxt="n", ylim=c(0, 10005), xlim=c(1, 56))#
     # axis(1, at = seq(0, 60, by=4), labels = (seq(1, 16, by=1)))#
#
      # mu_a <-  log(alive_at_age[age[-64]+1]/  alive_at_age[age[-64]])#
      # asp <- min(which(cumprod(mu_a)<=0.01) )#
     # mu_a[asp:length(mu_a)]=-5  #
     # m1<- lm(log(alive_at_age) ~ age) 	#
 	 # mu <- as.numeric(coef(m1)[2])#
 	 # legend("topright",   legend=round(mu, 5), lty=1)#
 	 # c(filename, exp(mu), exp(mu_a))#
 	 # }#
# quartz()#
 # par(mfrow=c(2, 3))#
# mapply(mort.est, state_data, state_filenames)
setwd("~/Documents/tuna_theory/model_output/")#
data_files <- list.files(pattern = "\\.csv$")#
#
repro_filenames <- data_files[((length(data_files)/3)+1):(2*(length(data_files)/3))]   #
state_filenames <- data_files[(2*(length(data_files)/3)+1):(3*(length(data_files)/3))]#
length_filenames <- data_files[1:(length(data_files)/3)]#
#
length_filenames <- unique(length_filenames)#
repro_filenames <- unique(repro_filenames)#
state_filenames <- unique(state_filenames)#
#
length_data <- lapply(length_filenames, read.csv)#
repro_data <- lapply(repro_filenames, read.csv)#
state_data <- lapply(state_filenames, read.csv)#
 quartz()#
  par(mfrow=c(2, 3))#
plot_length <- function(data, filenames) {#
	  #data[is.na(data)] <- 0#
     matplot(t(data[,-1]), type="l", main=c(substr(filenames, 9, 15), substr(filenames, 16, 21)), col="darkgray", lwd=1.75, lty=1,  ylab="Length (cm)", ylim=c(0, 400), xlim=c(0.5, 48), xlab= "Age (years)", xaxt="n")#
     axis(1, at = seq(0, 64, by=4), labels = (seq(1, 17, by=1)))#
     }#
 mapply(plot_length, length_data, length_filenames)    #
  # plot_hist <- function(data, filenames) {#
    # hist(data[, 12], breaks=50, xlim=c(50, 350), main=substr(filenames, 13, 49))#
  # }#
  # mapply(plot_hist, length_data, length_filenames)#
 quartz()#
  par(mfrow=c(2, 3))#
  plot_repro <- function(repro_data, repro_filenames) {#
     matplot(t(repro_data[,-1]), type="l", main=c(substr(repro_filenames, 8, 14), substr(repro_filenames, 18, 23)), col="darkgray", lwd=1.75, lty=1,   ylab="Reproduction (J)",   xlab= "Age (years)", xaxt="n", ylim=c(0, 6e+08), xlim=c(1, 56))#
     axis(1, at = seq(0, 60, by=4), labels = (seq(1, 16, by=1)))#
     }#
#
mapply(plot_repro, repro_data, repro_filenames)#
#
##make a plot of reproductive output as a function of length#
quartz()#
  par(mfrow=c(2, 3))#
 age.length <- function(length_data, repro_data, filenames) {#
 	matplot(t(length_data[,-1]), t(repro_data[,-1]), type="l", col="darkgray", lwd=1.75, lty=1, main=c(substr(filenames, 9, 15), substr(filenames, 16, 21)),  xlab="Length (cm)", xlim=c(0, 350), ylim=c(0, 1.5e+09), ylab="Reproduction (J)")#
 	} #
mapply(age.length, length_data, repro_data, length_filenames)#
 	#####now calculate the number alive as a function of age#
# #  mort.est <- function(idata, filename) {#
     # alive_at_age<- 10000.001 - colSums(apply(idata[,-1],2, is.na ))#
      # age=1:64#
      # plot(alive_at_age, type="l", lwd=2, ylab="Population size", main=c(substr(filename, 8, 14), substr(filename, 15, 20)), xlab= "Age (years)", xaxt="n", ylim=c(0, 10005), xlim=c(1, 56))#
     # axis(1, at = seq(0, 60, by=4), labels = (seq(1, 16, by=1)))#
#
      # mu_a <-  log(alive_at_age[age[-64]+1]/  alive_at_age[age[-64]])#
      # asp <- min(which(cumprod(mu_a)<=0.01) )#
     # mu_a[asp:length(mu_a)]=-5  #
     # m1<- lm(log(alive_at_age) ~ age) 	#
 	 # mu <- as.numeric(coef(m1)[2])#
 	 # legend("topright",   legend=round(mu, 5), lty=1)#
 	 # c(filename, exp(mu), exp(mu_a))#
 	 # }#
# quartz()#
 # par(mfrow=c(2, 3))#
# mapply(mort.est, state_data, state_filenames)
